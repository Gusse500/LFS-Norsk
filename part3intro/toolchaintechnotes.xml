<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-tools-toolchaintechnotes" xreflabel="Toolchain Technical Notes">
  <?dbhtml filename="toolchaintechnotes.html"?>

  <title>Verktøykjedens tekniske merknader</title>

  <para>Denne delen forklarer noen av begrunnelsen og de tekniske detaljene
   bak den overordnede byggemetoden. Det er ikke nødvendig å umiddelbart
   forstå alt i denne delen. Det meste av denne informasjonen vil være
   klarere etter å ha utført en faktisk konstruksjon. Denne delen kan refereres
   til når som helst under prosessen.</para>

  <para>Det overordnede målet for <xref linkend="chapter-cross-tools"/> og <xref
  linkend="chapter-temporary-tools"/> er å produsere et midlertidig område som
   inneholder et kjent sett med verktøy som kan isoleres fra vertssystemet.
   Ved bruk av <command>chroot</command>, kommandoene i de resterende kapitlene
   vil være inne i det miljøet, og sikre en ren, problemfri
   bygging av det nye LFS systemet. Byggeprosessen er designet for å
   minimere risikoen for nye lesere og gi den mest pedagogiske verdien
   samtidig.</para>

  <para>Byggeprosessen baserer seg på prosessen med
  <emphasis>krysskompilering</emphasis>. Krysskompilering brukes normalt
   for å bygge en kompilator og dens verktøykjede for en annen maskin enn
   den som brukes til byggingen. Dette er strengt tatt ikke nødvendig for LFS,
   siden maskinen der det nye systemet skal kjøre er den samme som den
   brukt til byggingen. Men krysskompilering har den store fordelen at
   alt som er krysskompilert ikke avhenger av vertsmiljøet.</para>

  <sect2 id="cross-compile" xreflabel="About Cross-Compilation">

    <title>Om Krysskompilering</title>

    <note>
      <para>
        LFS boken er ikke, og inneholder ikke en generell veiledning til
         å bygge en kryss (eller lokal) verktøykjede. Ikke bruk kommandoen i
         boken for en kryssverktøykjede som skal brukes til andre formål
         enn å bygge LFS, med mindre du virkelig forstår hva du gjør.
      </para>
    </note>

    <para>Krysskompilering involverer noen begreper som fortjener en seksjon for
     seg selv. Selv om denne delen kan utelates i en første lesning,
     å komme tilbake til det senere vil være gunstig for din fulle forståelse av
     prosessen.</para>

    <para>La oss først definere noen begreper som brukes i denne sammenhengen:</para>

    <variablelist>
      <varlistentry><term>bygg</term><listitem>
        <para>er maskinen der vi bygger programmer. Merk at denne maskinen
         refereres til som <quote>verten</quote> i andre
         seksjoner.</para></listitem>
      </varlistentry>

      <varlistentry><term>vert</term><listitem>
        <para>er maskinen/systemet der de bygde programmene skal kjøres. Merk
         at denne bruken av <quote>host</quote> ikke er den samme som i andre
         seksjoner.</para></listitem>
      </varlistentry>

      <varlistentry><term>mål</term><listitem>
        <para>brukes kun for kompilatorer. Det er maskinen kompilatoren
         produserer kode for. Det kan være forskjellig fra både build og
         host.</para></listitem>
      </varlistentry>

    </variablelist>

    <para>Som et eksempel, la oss forestille oss følgende scenario (noen ganger
     referert til som <quote>Canadian Cross</quote>): vi kan ha en
     kompilator bare på en treg maskin, la oss kalle det maskin A, og kompilatoren
     ccA. Vi kan også ha en rask maskin (B), men uten kompilator, og vi
     ønsker å produsere kode for en annen treg maskin (C). Å bygge en
     kompilator for maskin C, ville vi ha tre trinn:</para>

    <informaltable align="center">
      <tgroup cols="5">
        <colspec colnum="1" align="center"/>
        <colspec colnum="2" align="center"/>
        <colspec colnum="3" align="center"/>
        <colspec colnum="4" align="center"/>
        <colspec colnum="5" align="left"/>
        <thead>
          <row><entry>Stadie</entry><entry>Bygg</entry><entry>Vert</entry>
               <entry>Mål</entry><entry>Handling</entry></row>
        </thead>
        <tbody>
          <row>
            <entry>1</entry><entry>A</entry><entry>A</entry><entry>B</entry>
            <entry>bygg krysskompilator cc1 med ccA på maskin A</entry>
          </row>
          <row>
            <entry>2</entry><entry>A</entry><entry>B</entry><entry>C</entry>
            <entry>bygg krysskompilator cc2 med cc1 på maskin A</entry>
          </row>
          <row>
            <entry>3</entry><entry>B</entry><entry>C</entry><entry>C</entry>
            <entry>bygg kompilator ccC med cc2 på maskin B</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Deretter kan alle de andre programmene som trengs av maskin C kompileres
     ved å bruke cc2 på den raske maskinen B. Merk at med mindre B kan kjøre programmer
     produsert for C, er det ingen måte å teste de bygde programmene før maskinen
     C selv kjører. For eksempel, for å teste ccC, vil vi kanskje legge til en
     fjerde trinn:</para>

    <informaltable align="center">
      <tgroup cols="5">
        <colspec colnum="1" align="center"/>
        <colspec colnum="2" align="center"/>
        <colspec colnum="3" align="center"/>
        <colspec colnum="4" align="center"/>
        <colspec colnum="5" align="left"/>
        <thead>
          <row><entry>Stadie</entry><entry>Bygg</entry><entry>Vert</entry>
               <entry>Mål</entry><entry>Handling</entry></row>
        </thead>
        <tbody>
          <row>
            <entry>4</entry><entry>C</entry><entry>C</entry><entry>C</entry>
            <entry>bygge om og teste ccC ved å bruke seg selv på maskin C</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>I eksemplet ovenfor er bare cc1 og cc2 krysskompilatorer, det vil si
     de produserer kode for en annen maskin enn de de kjører på.
     De andre kompilatorene ccA og ccC produserer kode for maskinen de kjører
     på. Slike kompilatorer kalles <emphasis>lokale</emphasis> kompilatorer.</para>

  </sect2>

  <sect2 id="lfs-cross">
    <title>Implementering av Krysskompilering for LFS</title>

    <note>
      <para>Nesten alle byggesystemer bruker navn i formen
       cpu-vendor-kernel-os referert til som maskintripletten. En klok
       leseren kan lure på hvorfor en <quote>triplett</quote> refererer til et firekomponents
       navn. Årsaken er historie: i utgangspunktet var tre komponentnavn nok
       å angi en maskin entydig, men nye maskiner og systemer
       dukket opp, som viste seg utilstrekkelig. Ordet <quote>triplett</quote>
      hang igjen. En enkel måte å finne din maskintriplett på er å kjøre
       <command>config.guess</command>
      skript som følger med kilden for mange pakker. Pakk ut binutils
       kilder og kjør skriptet: <userinput>./config.guess</userinput> og merk deg
       utdataen. For eksempel, for en 32-bits Intel-prosessor
       utdataen vil være <emphasis>i686-pc-linux-gnu</emphasis>. På et 64-bit
       system blir det <emphasis>x86_64-pc-linux-gnu</emphasis>.</para>

      <para>Vær også oppmerksom på navnet på plattformens dynamiske lenker, ofte
       referert til som den dynamiske lasteren (ikke å forveksle med standard
       lenker <command>ld</command> som er en del av binutils). Den dynamiske lenkeren
       levert av Glibc finner og laster de delte bibliotekene som trengs av et
       program, forbereder programmet for kjøring, og deretter kjører det. Navnet på
       dynamisk lenker for en 32-bits Intel-maskin er <filename
      class="libraryfile">ld-linux.so.2</filename> og er <filename
      class="libraryfile">ld-linux-x86-64.so.2</filename> for 64-bits systemer. En
       sikker måte å bestemme navnet på den dynamiske lenkeren på er å inspisere en
       tilfeldig binær fra vertssystemet ved å kjøre: <userinput>readelf -l
      &lt;name of binary&gt; | grep interpreter</userinput> og legger merke til
       utdataen. Den autoritative referansen som dekker alle plattformer er i
      <filename>shlib-versions</filename> filen i roten til Glibc
       kildetreet.</para>
    </note>

    <para>For å forfalske en krysskompilering i LFS, navnet på vertstripletten
     justeres litt ved å endre &quot;vendor&quot; feltet i
    <envar>LFS_TGT</envar> variabelen. Vi bruker også
    <parameter>--with-sysroot</parameter> alternativet når du bygger krysslenkeren og
     krysskompilatoren for å fortelle dem hvor de skal finne de nødvendige vertsfilene. Dette
     sikrer at ingen av de andre programmene bygget i <xref
    linkend="chapter-temporary-tools"/> kan lenke til biblioteker på
     byggemaskinen. Kun to trinn er obligatoriske, og ett til for tester:</para>

    <informaltable align="center">
      <tgroup cols="5">
        <colspec colnum="1" align="center"/>
        <colspec colnum="2" align="center"/>
        <colspec colnum="3" align="center"/>
        <colspec colnum="4" align="center"/>
        <colspec colnum="5" align="left"/>
        <thead>
          <row><entry>Stadie</entry><entry>Bygg</entry><entry>Vert</entry>
               <entry>Mål</entry><entry>Handling</entry></row>
        </thead>
        <tbody>
          <row>
            <entry>1</entry><entry>pc</entry><entry>pc</entry><entry>lfs</entry>
            <entry>bygg krysskompilator cc1 ved å bruke cc-pc på pc</entry>
          </row>
          <row>
            <entry>2</entry><entry>pc</entry><entry>lfs</entry><entry>lfs</entry>
            <entry>bygg kompilator cc-lfs ved å bruke cc1 på pc</entry>
          </row>
          <row>
            <entry>3</entry><entry>lfs</entry><entry>lfs</entry><entry>lfs</entry>
            <entry>bygge om og teste cc-lfs ved å bruke seg selv på lfs</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>I tabellen ovenfor, <quote>på pc</quote> betyr at kommandoene kjøres
     på en maskin som bruker den allerede installerte distribusjonen. <quote>på
    lfs</quote> betyr at kommandoene kjøres i et chroot-miljø.</para>

    <para>Nå er det mer om krysskompilering: C-språket er ikke
     bare en kompilator, men definerer også et standardbibliotek. I denne boken blir
     GNU C-biblioteket, kalt glibc, brukt. Dette biblioteket må
     kompileres for lfs-maskinen, det vil si ved å bruke krysskompilatoren cc1.
     Men kompilatoren selv bruker interne bibliotekimplementeringskomplekse
     instruksjoner som ikke tilgjengelige i assembleranvisningssettet. Dette
     interne biblioteket heter libgcc, og må være koblet til glibc
     biblioteket for å være fullt funksjonelt! Videre må standardbiblioteket for
     C++ (libstdc++) også kobles til glibc. Løsningen på dette
     kylling og egg problemet er først å bygge en degradert cc1 basert libgcc,
     som mangler noen funksjoner som tråder og unntakshåndtering,
     bygge glibc ved å bruke denne degraderte kompilatoren (glibc selv er ikke
     degradert), og bygg deretter libstdc++. Men dette siste biblioteket vil mangle
     samme funksjonalitet som libgcc.</para>

    <para>Dette er ikke slutten på historien: konklusjonen av det foregående
     avsnittet er at cc1 ikke er i stand til å bygge en fullt funksjonell libstdc++, men
     dette er den eneste kompilatoren som er tilgjengelig for å bygge C/C++ bibliotekene
     under trinn 2! Selvfølgelig, kompilatoren bygget under trinn 2, cc-lfs,
     ville være i stand til å bygge disse bibliotekene, men (1) byggesystemet til
     GCC vet ikke at det er brukbart på pc, og (2) å bruke det på pc
     vil være en fare for å koble til pc-bibliotekene, siden cc-lfs er en lokal
     kompilator. Så vi må bygge libstdc++ senere, i chroot.</para>

  </sect2>

  <sect2 id="other-details">

    <title>Andre prosedyredetaljer</title>

    <para>Krysskompilatoren vil bli installert i en separat <filename
    class="directory">$LFS/tools</filename> mappe, siden det ikke vil
     være en del av det endelige systemet.</para>

    <para>Binutils installeres først fordi <command>configure</command>
    kjøringer av både GCC og Glibc utfører forskjellige funksjonstester på assembleren
     og lenker for å bestemme hvilke programvarefunksjoner som skal aktiveres eller deaktiveres. Dette
     er viktigere enn man kanskje først er klar over. En feilkonfigurert
     GCC eller Glibc kan resultere i en subtilt ødelagt verktøykjede, hvor virkningen av
     et slikt brudd ikke vises før mot slutten av konstruksjonen av
     hele distribusjonen. En feil i testserien vil vanligvis fremheve denne feilen
     før det utføres for mye tilleggsarbeid.</para>

    <para>Binutils installerer sin assembler og lenker på to steder,
    <filename class="directory">$LFS/tools/bin</filename> og <filename
    class="directory">$LFS/tools/$LFS_TGT/bin</filename>. Verktøyene i en
     plassering er hardlenket til den andre. En viktig fasett av lenkeren er
     bibliotekets søkerekkefølge. Detaljert informasjon kan fås fra
    <command>ld</command> ved å gi den <parameter>--verbose</parameter>
    flagget. For eksempel, <command>$LFS_TGT-ld --verbose | grep SEARCH</command>
    vil illustrere gjeldende søkestier og rekkefølgen deres. Det viser hvilken
     filer som er lenket av <command>ld</command> ved å kompilere et dummyprogram og
     gi <parameter>--verbose</parameter> parameteren til lenkeren. For
     eksempel,
    <command>$LFS_TGT-gcc dummy.c -Wl,--verbose 2&gt;&amp;1 | grep succeeded</command>
    vil vise alle filene som ble åpnet under koblingen.</para>

    <para>Den neste pakken som er installert er GCC. Et eksempel på hva som kan bli
     sett under kjøringen av <command>configure</command> er:</para>

<screen><computeroutput>checking what assembler to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/ld</computeroutput></screen>

    <para>Dette er viktig av grunnene nevnt ovenfor. Det viser også
     at GCCs konfigureringsskript ikke søker i PATH
     mapper for å finne hvilke verktøy det skal bruke. Imidlertid under selve
     kjøringen av <command>gcc</command>, er det ikke de samme søkestiene
     nødvendigvis brukt. For å finne ut hvilke standardlenker <command>gcc</command>
    vil bruke, kjør: <command>$LFS_TGT-gcc -print-prog-name=ld</command>.</para>

    <para>Detaljert informasjon kan fås fra <command>gcc</command> med
     å gi alternativet <parameter>-v</parameter> på kommandolinjen under kompilering
     av et dummy-program. For eksempel, <command>gcc -v dummy.c</command> Vil vise
     detaljert informasjon om forprosessorenkompileringen og sammenstillings
     stadier, inkludert <command>gcc</command> sine inkluderte søkestier og deres
     rekkefølge.</para>

    <para>Neste installert er desinfiserte Linux API deklarasjoner (headers). Disse tillater
     standard C-bibliotek (Glibc) å bruke funksjoner som Linux
     kjernen vil gi.</para>

    <para>Den neste pakken som blir installert er Glibc. Det viktigste
     hensyn for å bygge Glibc er kompilatoren, binære verktøy og
     kjernedeklarasjoner. Kompilatoren er generelt ikke et problem siden Glibc vil
     alltid bruke kompilatoren som er relatert til <parameter>--host</parameter>
    parameteret sendt til konfigureringsskriptet; f.eks. i vårt tilfelle kompilatoren
     vil være <command>$LFS_TGT-gcc</command>. De binære verktøyene og kjerne
     deklarasjoner kan være litt mer kompliserte. Derfor tar vi ingen risiko og bruker
     de tilgjengelige konfigurasjonsbryterne for å fremtvinge de riktige valgene. Etter
     kjøring av <command>configure</command>, sjekk innholdet i
    <filename>config.make</filename> filen i <filename
    class="directory">build</filename> mappen for alle viktige detaljer.
     Legg merke til bruken av <parameter>CC="$LFS_TGT-gcc"</parameter> (med
    <envar>$LFS_TGT</envar> utvidet) for å kontrollere hvilke binære verktøy som brukes
     og bruken av <parameter>-nostdinc</parameter> og
    <parameter>-isystem</parameter> flaggfor å kontrollere kompilatorens inkluderte
     søkeveier. Disse elementene fremhever et viktig aspekt ved Glibc
     pakken&mdash;den er veldig selvforsynt med tanke på byggemaskineriet
     og er generelt ikke avhengig av standardinnstillinger for verktøykjeder.</para>

    <para>Som nevnt ovenfor, blir standard C++-biblioteket kompilert som neste, etterfulgt i
    <xref linkend="chapter-temporary-tools"/> av alle programmene som må
     bygges selv. Installasjonstrinnet for alle disse pakkene bruker
    <envar>DESTDIR</envar> variabelen for å få
     programmene til å lande i LFS filsystemet.</para>

    <para>Ved slutten av <xref linkend="chapter-temporary-tools"/> den lokale
     lfs kompilatoren er installert. Første binutils-pass2 blir bygget,
     med det samme <envar>DESTDIR</envar> installasjon som de andre programmene,
     deretter konstrueres den andre passeringen av GCC, og utelater libstdc++
     og andre ikke-viktige biblioteker. På grunn av en merkelig logikk i GCC
     konfigureringsskript, <envar>CC_FOR_TARGET</envar> ender opp som
    <command>cc</command> når verten er den samme som målet, men er
     forskjellig fra byggesystemet. Det er derfor
    <parameter>CC_FOR_TARGET=$LFS_TGT-gcc</parameter> er satt eksplisitt inn i
     konfigureringsalternativene.</para>

    <para>Når du kommer inn i chroot-miljøet i <xref
    linkend="chapter-chroot-temporary-tools"/>, den første oppgaven er å installere
     libstdc++. Deretter utføres midlertidige installasjoner av programmer som trengs for riktig
     betjening av verktøykjeden. Fra dette tidspunktet og fremover er
     kjerneverktøykjeden selvstendig og selvbetjent. I
    <xref linkend="chapter-building-system"/>, bygges, testes og
     installeres de endelige versjonene av alle
     pakker som trengs for et fullt funksjonelt system.</para>

  </sect2>

</sect1>
