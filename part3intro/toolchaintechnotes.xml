<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-tools-toolchaintechnotes" xreflabel="Verkt顯kjedens tekniske merknader">
  <?dbhtml filename="toolchaintechnotes.html"?>

  <title>Verkt칮ykjedens tekniske merknader</title>

  <para>Denne delen forklarer noen av begrunnelsen og de tekniske detaljene
  bak den overordnede byggemetoden. Det er ikke n칮dvendig 친 umiddelbart
  forst친 alt i denne delen. Det meste av denne informasjonen vil v칝re
  klarere etter 친 ha utf칮rt en faktisk konstruksjon. Denne delen kan refereres
  til n친r som helst under prosessen.</para>

  <para>Det overordnede m친let for <xref linkend="chapter-cross-tools"/> og <xref
  linkend="chapter-temporary-tools"/> er 친 produsere et midlertidig omr친de som
  inneholder et kjent sett med verkt칮y som kan isoleres fra vertssystemet.
  Ved bruk av <command>chroot</command> kommandoene, kompilasjonene i de resterende kapitlene
  vil v칝re isolert inne i det milj칮et, og sikre en ren, problemfri
  bygging av det nye LFS systemet. Byggeprosessen er designet for 친
  minimere risikoen for nye lesere og gi den mest pedagogiske verdien
  samtidig.</para>

  <para>Byggeprosessen baserer seg p친
  <emphasis>krysskompilering</emphasis>. Krysskompilering brukes normalt
  for 친 bygge en kompilator og dens verkt칮ykjede for en annen maskin enn
  den som brukes til byggingen. Dette er strengt tatt ikke n칮dvendig for LFS,
  siden maskinen der det nye systemet skal kj칮re er den samme som den
  brukt til byggingen. Men krysskompilering har den store fordelen at
  alt som er krysskompilert ikke avhenger av vertsmilj칮et.</para>

  <sect2 id="cross-compile" xreflabel="About Cross-Compilation">

    <title>Om Krysskompilering</title>

    <note>
      <para>
        LFS boken er ikke, og inneholder ikke en generell veiledning til
        친 bygge en kryss (eller lokal) verkt칮ykjede. Ikke bruk kommandoen i
        boken for en kryssverkt칮ykjede som skal brukes til andre form친l
        enn 친 bygge LFS, med mindre du virkelig forst친r hva du gj칮r.
      </para>
    </note>

    <para>Krysskompilering involverer noen begreper som fortjener en seksjon for
    seg selv. Selv om denne delen kan utelates i en f칮rste lesning,
    친 komme tilbake til det senere vil v칝re gunstig for din fulle forst친else av
    prosessen.</para>

    <para>La oss f칮rst definere noen begreper som brukes i denne sammenhengen.</para>

    <variablelist>
      <varlistentry><term>bygg</term><listitem>
        <para>er maskinen der vi bygger programmer. Merk at denne maskinen
        er ogs친 referert til som <quote>verten</quote>.</para></listitem>
      </varlistentry>

      <varlistentry><term>vert</term><listitem>
        <para>er maskinen/systemet der de bygde programmene skal kj칮res. Merk
        at denne bruken av <quote>verten</quote> ikke er den samme som i andre
        seksjoner.</para></listitem>
      </varlistentry>

      <varlistentry><term>m친l</term><listitem>
        <para>brukes kun for kompilatorer. Det er maskinen kompilatoren
        produserer kode for. Det kan v칝re forskjellig fra b친de bygg og
        vertent.</para></listitem>
      </varlistentry>

    </variablelist>

    <para>Som et eksempel, la oss forestille oss f칮lgende scenario (noen ganger
    referert til som <quote>Canadian Cross</quote>). vi har en
    kompilator bare p친 en treg maskin, la oss kalle det maskin A, og kompilatoren
    ccA. Vi kan ogs친 ha en rask maskin (B), men uten kompilator, og vi
    칮nsker 친 produsere kode for en annen treg maskin (C). 칀 bygge en
    kompilator for maskin C, ville vi ha tre trinn:</para>

    <informaltable align="center">
      <tgroup cols="5">
        <colspec colnum="1" align="center"/>
        <colspec colnum="2" align="center"/>
        <colspec colnum="3" align="center"/>
        <colspec colnum="4" align="center"/>
        <colspec colnum="5" align="left"/>
        <thead>
          <row><entry>Stadie</entry><entry>Bygg</entry><entry>Vert</entry>
               <entry>M친l</entry><entry>Handling</entry></row>
        </thead>
        <tbody>
          <row>
            <entry>1</entry><entry>A</entry><entry>A</entry><entry>B</entry>
            <entry>bygg krysskompilator cc1 med ccA p친 maskin A</entry>
          </row>
          <row>
            <entry>2</entry><entry>A</entry><entry>B</entry><entry>C</entry>
            <entry>bygg krysskompilator cc2 med cc1 p친 maskin A</entry>
          </row>
          <row>
            <entry>3</entry><entry>B</entry><entry>C</entry><entry>C</entry>
            <entry>bygg kompilator ccC med cc2 p친 maskin B</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Deretter kan alle de andre programmene som trengs av maskin C kompileres
    ved 친 bruke cc2 p친 den raske maskinen B. Merk at med mindre B kan kj칮re programmer
    produsert for C, er det ingen m친te 친 teste de bygde programmene f칮r maskinen
    C selv kj칮rer. For eksempel, for 친 teste ccC, vil vi kanskje legge til en
    fjerde trinn:</para>

    <informaltable align="center">
      <tgroup cols="5">
        <colspec colnum="1" align="center"/>
        <colspec colnum="2" align="center"/>
        <colspec colnum="3" align="center"/>
        <colspec colnum="4" align="center"/>
        <colspec colnum="5" align="left"/>
        <thead>
          <row><entry>Stadie</entry><entry>Bygg</entry><entry>Vert</entry>
               <entry>M친l</entry><entry>Handling</entry></row>
        </thead>
        <tbody>
          <row>
            <entry>4</entry><entry>C</entry><entry>C</entry><entry>C</entry>
            <entry>bygge om og teste ccC ved 친 bruke seg selv p친 maskin C</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>I eksemplet ovenfor er bare cc1 og cc2 krysskompilatorer, det vil si
    de produserer kode for en annen maskin enn de de kj칮rer p친.
    De andre kompilatorene ccA og ccC produserer kode for maskinen de kj칮rer
    p친. Slike kompilatorer kalles <emphasis>lokale</emphasis> kompilatorer.</para>

  </sect2>

  <sect2 id="lfs-cross">
    <title>Implementering av Krysskompilering for LFS</title>

    <note>
      <para>Alle de krysskompilerte pakkene i denne boken bruker en
      autoconf basert byggesystem. Det autoconf baserte byggesystemet
      godtar systemtyper i formen cpu-vendor-kernel-os,
      referert til som systemtripletten. Siden leverand칮rfeltet ofte er
      irrelevant, autoconf lar deg utelate det.</para>
      
      <para>En klok leser kan lure p친
      hvorfor en <quote>triplett</quote> refererer til et firekomponents navn.
      Kjernefeltet og os-feltet begynte som et enkelt
      <quote>system</quote> felt.  Et slikt trefeltsskjema er fortsatt gyldig
      i dag for noen systemer, for eksempel,
      <literal>x86_64-unknown-freebsd</literal>.  Men
      to systemer kan dele samme kjerne og fortsatt v칝re for forskjellige for 친
      bruke den samme tripletten for 친 beskrive dem. For eksempel Android kj칮rende p친 en
      mobiltelefon er helt forskjellig fra Ubuntu som kj칮rer p친 en ARM64
      server, selv om de begge kj칮rer p친 samme type CPU (ARM64) og
      bruker samme kjerne (Linux).</para>
      
      <para>Uten et emuleringslag kan du ikke kj칮re en
      kj칮rbar fil for en server p친 en mobiltelefon eller omvendt. S친
      <quote>system</quote> feltet har blitt delt inn i kjerne- og os-felt, for
      친 angi disse systemene entydig. I v친rt eksempel, Android
      systemet er angitt <literal>aarch64-unknown-linux-android</literal>,
      og Ubuntu systemet er angitt
      <literal>aarch64-unknown-linux-gnu</literal>.</para>
      
      <para>Ordet <quote>triplett</quote> forblir innebygd i leksikonet. En enkel m친te 친 bestemme din
      systemtriplett er 친 kj칮re <command>config.guess</command>
      skript som f칮lger med kilden for mange pakker. Pakk ut binutils sine
      kilder, kj칮r skriptet <userinput>./config.guess</userinput>, og merk
      utdaten. For eksempel, for en 32-bits Intel-prosessor
      utdataen vil v칝re <emphasis>i686-pc-linux-gnu</emphasis>. P친 et 64-bit
      system blir det <emphasis>x86_64-pc-linux-gnu</emphasis>. P친 de fleste
      Linux systemer den enklere <command>gcc -dumpmachine</command> kommando
      vil gi deg lignende informasjon.</para>

      <para>V칝r ogs친 oppmerksom p친 navnet p친 plattformens dynamiske lenker, ofte
      referert til som den dynamiske lasteren (ikke 친 forveksle med standard
      lenker <command>ld</command> som er en del av binutils). Den dynamiske lenkeren
      levert av Glibc finner og laster de delte bibliotekene som trengs av et
      program, forbereder programmet for kj칮ring, og deretter kj칮rer det. Navnet p친
      dynamisk lenker for en 32-bits Intel-maskin er <filename
      class="libraryfile">ld-linux.so.2</filename>; og er <filename
      class="libraryfile">ld-linux-x86-64.so.2</filename> for 64-bits systemer. En
      sikker m친te 친 bestemme navnet p친 den dynamiske lenkeren p친 er 친 inspisere en
      tilfeldig bin칝r fra vertssystemet ved 친 kj칮re: <userinput>readelf -l
      &lt;navn p친 bin칝r&gt; | grep interpreter</userinput> og legg merke til
      utdataen. Den autoritative referansen som dekker alle plattformer er i
      <filename>shlib-versions</filename> filen i roten til Glibc
      kildetreet.</para>
    </note>

    <para>For 친 forfalske en krysskompilering i LFS, navnet p친 vertstripletten
    justeres litt ved 친 endre &quot;vendor&quot; feltet i
    <envar>LFS_TGT</envar> variabel s친 det st친r &quot;lfs&quot;. Vi bruker ogs친
    <parameter>--with-sysroot</parameter> alternativet n친r du bygger krysslenkeren og
    krysskompilatoren for 친 fortelle dem hvor de skal finne de n칮dvendige vertsfilene. Dette
    sikrer at ingen av de andre programmene bygget i <xref
    linkend="chapter-temporary-tools"/> kan lenke til biblioteker p친
    byggemaskinen. Kun to trinn er obligatoriske, og ett til for tester:</para>

    <informaltable align="center">
      <tgroup cols="5">
        <colspec colnum="1" align="center"/>
        <colspec colnum="2" align="center"/>
        <colspec colnum="3" align="center"/>
        <colspec colnum="4" align="center"/>
        <colspec colnum="5" align="left"/>
        <thead>
          <row><entry>Stadie</entry><entry>Bygg</entry><entry>Vert</entry>
               <entry>M친l</entry><entry>Handling</entry></row>
        </thead>
        <tbody>
          <row>
            <entry>1</entry><entry>pc</entry><entry>pc</entry><entry>lfs</entry>
            <entry>Bygg krysskompilator cc1 ved 친 bruke cc-pc p친 pc</entry>
          </row>
          <row>
            <entry>2</entry><entry>pc</entry><entry>lfs</entry><entry>lfs</entry>
            <entry>Bygg kompilator cc-lfs ved 친 bruke cc1 p친 pc</entry>
          </row>
          <row>
            <entry>3</entry><entry>lfs</entry><entry>lfs</entry><entry>lfs</entry>
            <entry>Bygge om og teste cc-lfs ved 친 bruke seg selv p친 lfs</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>I tabellen ovenfor, <quote>p친 pc</quote> betyr at kommandoene kj칮res
    p친 en maskin som bruker den allerede installerte distribusjonen. <quote>p친
    lfs</quote> betyr at kommandoene kj칮res i et chroot-milj칮.</para>

    <para>Dette er enn친 ikke slutten p친 historien. C-spr친ket er ikke
    bare en kompilator; den definerer ogs친 et standardbibliotek. I denne boken er det
    GNU C-biblioteket, kalt glibc, som brukes (det finnes et alternativ, &quot;musl&quot;). Dette biblioteket m친
    kompileres for LFS-maskinen; det vil si 친 bruke krysskompilatoren cc1.
    Men kompilatoren selv bruker et internt bibliotek som gir komplekse
    subrutiner for funksjoner som ikke er tilgjengelige i assembler-instruksjonssettet. Dette
    interne biblioteket heter libgcc, og det m친 v칝re koblet til glibc for at
    biblioteket skal v칝re fullt funksjonelt. Videre standardbiblioteket for
    C++ (libstdc++) m친 ogs친 v칝re koblet til glibc. L칮sningen p친 dette
    kylling og egg problemet er f칮rst 친 bygge en nedgradert cc1-basert libgcc,
    mangler noen funksjoner som tr친der og unntaksh친ndtering, og da
    친 bygge glibc ved 친 bruke denne nedgraderte kompilatoren (glibc selv er ikke
    nedgradert), og ogs친 for 친 bygge libstdc++. Dette siste biblioteket vil mangle noe av
    funksjonaliteten til libgcc.</para>

    <para>Resultatet av det foreg친ende avsnittet er at cc1 ikke er i stand til 친
    bygge et fullt funksjonell libstdc++ med den nedgraderte libgcc, men cc1
    er den eneste kompilatoren som er tilgjengelig for 친 bygge C/C++-bibliotekene
    under fase 2. Det er to grunner til at vi ikke umiddelbart bruker
    kompilator bygget i trinn 2, cc-lfs, for 친 bygge disse bibliotekene.</para>

    <itemizedlist>
      <listitem>
        <para>
          Generelt sett kan ikke cc-lfs kj칮re p친 pc (vertssystemet). Selv om
          triplettene for pc og lfs er kompatible med hverandre, en kj칮rbar fil
          for lfs m친 avhenge av glibc-&glibc-version;; vertsdistroen
          kan bruke en annen implementering av libc (for eksempel musl), eller
          en tidligere utgivelse av glibc (for eksempel, glibc-2.13).
        </para>
      </listitem>
      <listitem>
        <para>
          Selv om cc-lfs kan kj칮re p친 pc, vil det 친 bruke det p친 pc skape
          en risiko for 친 koble til pc-bibliotekene, siden cc-lfs er en lokal
          kompilator.
        </para>
      </listitem>
    </itemizedlist>

    <para>S친 n친r vi bygger gcc trinn 2, instruerer vi byggesystemet til
    친 gjenoppbygge libgcc og libstdc++ med cc1, men vi kobler libstdc++ til den nye
    gjenoppbygde libgcc i stedet for den gamle, nedgraderte konstruksjonen. Dette gj칮r den ombygde
    libstdc++ fullt funksjonell.</para>

    <para>I &ch-final; (eller <quote>stage 3</quote>), alle pakkene som trengs for
    LFS systemet er bygget. Selv om en pakke allerede er installert i
    LFS systemet i et tidligere kapittel, bygger vi fortsatt pakken p친 nytt. Hoved친rsaken til
    친 gjenoppbygge disse pakkene er 친 gj칮re dem stabile: hvis vi installerer en LFS pakke p친 nytt
    p친 et fullf칮rt LFS system, det reinstallerte innholdet i pakken
    skal v칝re det samme som innholdet i den samme pakken n친r den f칮rst installeres i
    &ch-final;.  De midlertidige pakkene installert i &ch-tmp-cross; eller
    &ch-tmp-chroot; kan ikke tilfredsstille dette kravet, fordi noen av dem
    er bygget uten valgfrie avhengigheter, og autoconf kan ikke
    utf칮re noen funksjonsinnsjekker &ch-tmp-cross; p친 grunn av krysskompilering,
    for친rsaker at de midlertidige pakkene mangler valgfrie funksjoner,
    eller bruker suboptimale koderutiner. I tillegg en mindre grunn til
    gjenoppbygging av pakkene er 친 kj칮re testpakkene.</para>

  </sect2>

  <sect2 id="other-details">

    <title>Andre prosedyredetaljer</title>

    <para>Krysskompilatoren vil bli installert i en separat <filename
    class="directory">$LFS/tools</filename> mappe, siden den ikke vil
    v칝re en del av det endelige systemet.</para>

    <para>Binutils installeres f칮rst fordi <command>configure</command>
    kj칮ringer av b친de GCC og Glibc utf칮rer forskjellige funksjonstester p친 assembleren
    og lenker for 친 bestemme hvilke programvarefunksjoner som skal aktiveres eller deaktiveres. Dette
    er viktigere enn man kanskje f칮rst er klar over. En feilkonfigurert
    GCC eller Glibc kan resultere i en subtilt 칮delagt verkt칮ykjede, hvor virkningen av
    et slikt brudd ikke vises f칮r mot slutten av konstruksjonen av
    hele distribusjonen. En feil i testserien vil vanligvis fremheve denne feilen
    f칮r det utf칮res for mye tilleggsarbeid.</para>

    <para>Binutils installerer sin assembler og lenker p친 to steder,
    <filename class="directory">$LFS/tools/bin</filename> og <filename
    class="directory">$LFS/tools/$LFS_TGT/bin</filename>. Verkt칮yene i en
    plassering er hardlenket til den andre. En viktig fasett av lenkeren er
    bibliotekets s칮kerekkef칮lge. Detaljert informasjon kan f친s fra
    <command>ld</command> ved 친 gi den <parameter>--verbose</parameter>
    flagget. For eksempel, <command>$LFS_TGT-ld --verbose | grep SEARCH</command>
    vil illustrere gjeldende s칮kestier og rekkef칮lgen deres. (Merk at dette
    eksempelet kan kj칮res som vist kun mens du er logget p친 som bruker
    <systemitem class="username">lfs</systemitem>. Hvis du kommer tilbake til denne
    siden senere, bytt ut <command>$LFS_TGT-ld</command> med
    <command>ld</command>).</para>

    <para>Den neste pakken som er installert er GCC. Et eksempel p친 hva som kan bli
    sett under kj칮ringen av <command>configure</command> er:</para>

<screen><computeroutput>checking what assembler to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/ld</computeroutput></screen>

    <para>Dette er viktig av grunnene nevnt ovenfor. Det viser ogs친
    at GCCs konfigureringsskript ikke s칮ker i STI (PATH)
    mapper for 친 finne hvilke verkt칮y det skal bruke. Imidlertid under selve
    kj칮ringen av <command>gcc</command> er ikke de samme s칮kestiene
    n칮dvendigvis brukt. For 친 finne ut hvilke standardlenker <command>gcc</command>
    vil bruke, kj칮r: <command>$LFS_TGT-gcc -print-prog-name=ld</command>. (En gang til,
    fjern <command>$LFS_TGT-</command> prefikset hvis du kommer tilbake til dette
    seinere.)</para>

    <para>Detaljert informasjon kan f친s fra <command>gcc</command> med
    친 gi alternativet <parameter>-v</parameter> p친 kommandolinjen under kompilering
     av et program. For eksempel, <command>$LFS_TGT-gcc -v
    <replaceable>example.c</replaceable></command> (eller uten <command>
    $LFS_TGT-</command> hvis du kommer tilbake senere) vises
    detaljert informasjon om forprosessoren, kompileringen og sammenstillings
    stadier, inkludert <command>gcc</command> sine s칮kestier for inkluderte
    deklarasjoner og deres rekkef칮lge.</para>

    <para>Neste, desinfiserte Linux API deklarasjoner (headers). Disse tillater
    standard C-bibliotek (Glibc) 친 bruke funksjoner som Linux
    kjernen vil gi.</para>

    <para>Neste kommer glibc. Det viktigste
    hensynet for 친 bygge glibc er kompilatoren, bin칝re verkt칮y og
    kjernedeklarasjoner. Kompilatoren er generelt ikke et problem siden glibc vil
    alltid bruke kompilatoren som er relatert til <parameter>--host</parameter>
    parameteret sendt til konfigureringsskriptet; f.eks. i v친rt tilfelle kompilatoren
    vil v칝re <command>$LFS_TGT-gcc</command>. De bin칝re verkt칮yene og kjerne
    deklarasjoner kan v칝re litt mer kompliserte. Derfor tar vi ingen risiko og bruker
    de tilgjengelige konfigurasjonsbryterne for 친 fremtvinge de riktige valgene. Etter
    kj칮ring av <command>configure</command>, sjekk innholdet i
    <filename>config.make</filename> filen i <filename
    class="directory">build</filename> mappen for alle viktige detaljer.
    Legg merke til bruken av <parameter>CC="$LFS_TGT-gcc"</parameter> (med
    <envar>$LFS_TGT</envar> utvidet) for 친 kontrollere hvilke bin칝re verkt칮y som brukes
    og bruken av <parameter>-nostdinc</parameter> og
    <parameter>-isystem</parameter> flagg for 친 kontrollere kompilatorens inkluderte
    s칮keveier. Disse elementene fremhever et viktig aspekt ved Glibc
    pakken&mdash;en er veldig selvforsynt med tanke p친 byggemaskineriet
    og er generelt ikke avhengig av standardinnstillinger for verkt칮ykjeder.</para>

    <para>Som nevnt ovenfor, blir standard C++-biblioteket kompilert som neste, etterfulgt i
    <xref linkend="chapter-temporary-tools"/> av andre programmer som m친
    krysskompileres for 친 bryte sirkul칝re avhengigheter p친 byggetidspunktet.
    Installasjonstrinnet for alle disse pakkene bruker
    <envar>DESTDIR</envar> variabel for 친 tvinge installasjonen
    inn i LFS filsystemet.</para>

    <para>Ved slutten av <xref linkend="chapter-temporary-tools"/> den lokale
    lfs kompilatoren er installert. F칮rste binutils-pass2 blir bygget,
    med den samme <envar>DESTDIR</envar> mappen som de andre programmene,
    deretter konstrueres den andre passeringen av GCC, og utelater libstdc++
    og andre ikke-viktige biblioteker. P친 grunn av en merkelig logikk i GCC
    konfigureringsskript, <envar>CC_FOR_TARGET</envar> ender opp som
    <command>cc</command> n친r verten er den samme som m친let, men er
    forskjellig fra byggesystemet. Det er derfor
    <parameter>CC_FOR_TARGET=$LFS_TGT-gcc</parameter> er erkl칝rt eksplisitt
    som et av konfigurasjonsalternativene.</para>

    <para>N친r du kommer inn i chroot-milj칮et i <xref
    linkend="chapter-chroot-temporary-tools"/>,
    de midlertidige installasjonene av programmer som trengs for riktig
    betjening av verkt칮ykjeden utf칮res. Fra dette tidspunktet og fremover
    er kjerneverkt칮ykjeden selvstendig og selvhostet. I
    <xref linkend="chapter-building-system"/>, endelige versjoner av alle
    pakker som trengs for et fullt funksjonelt system bygges, testes og
    installert.</para>

  </sect2>

</sect1>
